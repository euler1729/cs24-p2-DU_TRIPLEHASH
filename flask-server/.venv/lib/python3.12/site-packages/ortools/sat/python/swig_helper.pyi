import ortools.util.python.sorted_interval_list
from typing import Callable

class CpSatHelper:
    def __init__(self, *args, **kwargs) -> None: ...
    @staticmethod
    def model_stats(model_proto) -> str: ...
    @staticmethod
    def solver_response_stats(response) -> str: ...
    @staticmethod
    def validate_model(model_proto) -> str: ...
    @staticmethod
    def variable_domain(variable_proto) -> ortools.util.python.sorted_interval_list.Domain: ...
    @staticmethod
    def write_model_to_file(model_proto, filename: str) -> bool: ...

class SolutionCallback:
    def __init__(self) -> None: ...
    def BestObjectiveBound(self) -> float: ...
    def DeterministicTime(self) -> float: ...
    def HasResponse(self) -> bool: ...
    def NumBinaryPropagations(self) -> int: ...
    def NumBooleans(self) -> int: ...
    def NumBranches(self) -> int: ...
    def NumConflicts(self) -> int: ...
    def NumIntegerPropagations(self) -> int: ...
    def ObjectiveValue(self) -> float: ...
    def OnSolutionCallback(self) -> None: ...
    def Response(self, *args, **kwargs): ...
    def SolutionBooleanValue(self, index: int) -> bool: ...
    def SolutionIntegerValue(self, index: int) -> int: ...
    def StopSearch(self) -> None: ...
    def UserTime(self) -> float: ...
    def WallTime(self) -> float: ...

class SolveWrapper:
    def __init__(self) -> None: ...
    def add_best_bound_callback(self, best_bound_callback: Callable[[float], None]) -> None: ...
    def add_log_callback(self, log_callback: Callable[[str], None]) -> None: ...
    def add_solution_callback(self, callback: SolutionCallback) -> None: ...
    def clear_solution_callback(self, arg0: SolutionCallback) -> None: ...
    def set_parameters(self, parameters) -> None: ...
    def solve(self, *args, **kwargs): ...
    def stop_search(self) -> None: ...
