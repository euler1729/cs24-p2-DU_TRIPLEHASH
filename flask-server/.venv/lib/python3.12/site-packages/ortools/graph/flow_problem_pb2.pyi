"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
Protobuf representing a flow problem on a graph. It supports several problem
types. Depending on the type, the message is interpreted differently as
explained under each type description below.

LINEAR_SUM_ASSIGNMENT: the algorithm computes the minimum-cost perfect
matching if there is one.
 - Arcs are assumed to be from a left node to a right node. In particular
   the id space of the left and right nodes can be the same. That is an arc
   from the left node 0 to the right node 0 will be coded as (0, 0).
 - If a perfect matching does not exist, the problem is not feasible.
 - Capacity and supply values are ignored.

MAX_FLOW: The algorithm computes the maximum flow under the arc capacity
constraints.
 - Only one source (with supply > 0) and one sink (with supply < 0), the
   supply values are not important. Only the signs are.
 - The costs are ignored.

MIN_COST_FLOW: the algorithm computes the flow of minimum cost. If a feasible
flow does not exist (in particular if the sum of supplies is not 0), the
problem is not feasible.
"""

import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

@typing.final
class FlowArcProto(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TAIL_FIELD_NUMBER: builtins.int
    HEAD_FIELD_NUMBER: builtins.int
    CAPACITY_FIELD_NUMBER: builtins.int
    UNIT_COST_FIELD_NUMBER: builtins.int
    tail: builtins.int
    """A directed arc goes from a tail node to a head node.
    Node ids must be non-negative (>= 0).
    """
    head: builtins.int
    capacity: builtins.int
    """Capacity of the arc. Must be non-negative (>= 0). If the capacity is zero,
    it is equivalent to not including the arc in the FlowModelProto.
    """
    unit_cost: builtins.int
    """Cost of this arc per unit of flow.
    Note that it can take any positive, negative or null value.
    """
    def __init__(
        self,
        *,
        tail: builtins.int | None = ...,
        head: builtins.int | None = ...,
        capacity: builtins.int | None = ...,
        unit_cost: builtins.int | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["capacity", b"capacity", "head", b"head", "tail", b"tail", "unit_cost", b"unit_cost"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["capacity", b"capacity", "head", b"head", "tail", b"tail", "unit_cost", b"unit_cost"]) -> None: ...

global___FlowArcProto = FlowArcProto

@typing.final
class FlowNodeProto(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ID_FIELD_NUMBER: builtins.int
    SUPPLY_FIELD_NUMBER: builtins.int
    id: builtins.int
    """The ids must be non-negative (>= 0). They should be dense for good
    performance. Note that it is not mandatory to include nodes with no supply
    in a FlowModelProto.
    """
    supply: builtins.int
    """The supply can be positive or negative in which case it means demand.
    The sum of the supplies over all nodes must always be 0.
    """
    def __init__(
        self,
        *,
        id: builtins.int | None = ...,
        supply: builtins.int | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["id", b"id", "supply", b"supply"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["id", b"id", "supply", b"supply"]) -> None: ...

global___FlowNodeProto = FlowNodeProto

@typing.final
class FlowModelProto(google.protobuf.message.Message):
    """Holds a flow problem, see NodeProto and ArcProto for more details."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _ProblemType:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _ProblemTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[FlowModelProto._ProblemType.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        LINEAR_SUM_ASSIGNMENT: FlowModelProto._ProblemType.ValueType  # 0
        MAX_FLOW: FlowModelProto._ProblemType.ValueType  # 1
        MIN_COST_FLOW: FlowModelProto._ProblemType.ValueType  # 2

    class ProblemType(_ProblemType, metaclass=_ProblemTypeEnumTypeWrapper):
        """The type of problem to solve."""

    LINEAR_SUM_ASSIGNMENT: FlowModelProto.ProblemType.ValueType  # 0
    MAX_FLOW: FlowModelProto.ProblemType.ValueType  # 1
    MIN_COST_FLOW: FlowModelProto.ProblemType.ValueType  # 2

    NODES_FIELD_NUMBER: builtins.int
    ARCS_FIELD_NUMBER: builtins.int
    PROBLEM_TYPE_FIELD_NUMBER: builtins.int
    problem_type: global___FlowModelProto.ProblemType.ValueType
    @property
    def nodes(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___FlowNodeProto]: ...
    @property
    def arcs(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___FlowArcProto]: ...
    def __init__(
        self,
        *,
        nodes: collections.abc.Iterable[global___FlowNodeProto] | None = ...,
        arcs: collections.abc.Iterable[global___FlowArcProto] | None = ...,
        problem_type: global___FlowModelProto.ProblemType.ValueType | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["problem_type", b"problem_type"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["arcs", b"arcs", "nodes", b"nodes", "problem_type", b"problem_type"]) -> None: ...

global___FlowModelProto = FlowModelProto
